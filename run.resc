# run.resc
# ─────────────────────────────────────────────────────────────────────────
# Run the mock-SPI demo on a simulated STM32F4 Discovery Kit.
#
# Prerequisites (all paths relative to the directory you run Renode from):
#   MockSpiPeripheral.cs   – the C# peripheral model
#   mock_spi_board.repl    – the platform extension that attaches it
#   target/thumbv7em-none-eabihf/release/mock-spi-demo   – the ELF binary
#
# Usage:
#   renode --console run.resc
#
# The UART2 analyzer will pop up (or print to console in --console mode)
# showing the test results.  A GDB server is also started on port 3333 so
# you can connect with:
#   arm-none-eabi-gdb -ex "target remote :3333" \
#       target/thumbv7em-none-eabihf/release/mock-spi-demo
# ─────────────────────────────────────────────────────────────────────────

# ── Tuneable variables (override on command line with -e) ──────────────
$name?="STM32F4_MockSPI"
$elf?="target/thumbv7em-none-eabihf/release/mock-spi-device"
$cs_file?=@MockSpiPeripheral.cs
$board_repl?=@mock_spi_board.repl

# ── Compile and register the C# peripheral model ───────────────────────
# Renode ships with an on-the-fly C# compiler (Mono or dotnet depending on
# the portable package variant).  `include` compiles the .cs file and makes
# its types available immediately.
include $cs_file
EnsureTypeIsLoaded "Antmicro.Renode.Peripherals.SPI.MockSpiPeripheral"

# ── Create the machine ─────────────────────────────────────────────────
mach create $name

# ── Load platform (stock board + CCM + mock peripheral) ────────────────
machine LoadPlatformDescription $board_repl

logLevel -1

# ── Show the UART2 output ──────────────────────────────────────────────
showAnalyzer sysbus.usart2

# ── GDB server ─────────────────────────────────────────────────────────
machine StartGdbServer 3333

# ── Initial load + start ───────────────────────────────────────────────
sysbus LoadELF @target/thumbv7em-none-eabihf/release/mock_spi_device
start
